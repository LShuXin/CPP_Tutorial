# C++ 你最好记住的知识点

[toc]



> C++ 基本的使用都比较容易熟悉，但是，不常用或者说只有在实际某些项目中才会用到的就会显得比较陌生，这里把不常用的一些总结一下。包括概念，语法函数等。



## C++ **是不是类型安全的？**

不是。两个不同类型的指·针之间可以强制转换（用reinterpret cast)。C# 是类型安全的。

 

## main **函数执行以前，还会执行什么代码？**

全局对象的构造函数会在main 函数之前执行。

 

## 描述内存分配方式以及它们的区别

1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 



## 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

1、生命周期不同：

全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

2、使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。

3、操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

 

## 多态，虚函数，纯虚函数

1、多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：

·   在程序运行时的多态性通过继承和虚函数来体现；

·   在程序编译时多态性体现在函数和运算符的重载上；

2、虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

3、纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在，纯虚函数不具备函数的功能，一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

 

## 虚函数和纯虚函数的区别

1、纯虚函数声明如下： virtual void funtion1() = 0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

2、虚函数声明如下：virtual ReturnType FunctionName(Parameter); 虚函数必须实现，如果不实现，编译器将报错，错误提示为：error LNK****: unresolved external symbol “public: virtual void __thiscall ClassName::virtualFunctionName(void)”

3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

6、**在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。**

7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。

8、**析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。**

9、有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。

 10、定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义，或者给出实现也没有意义。

11. **实际上我个人认为纯虚函数的引入，是出于两个目的**

- 为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。

- 为了效率，不是程序执行的效率，而是为了编码的效率。

12、基类的析构函数不是虚函数，会带来什么问题？

派生类的析构函数用不上，会造成资源的泄漏。



## const 与 #define 相比，有何优点？

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。



## new、delete、malloc、free关系

- delete 会调用对象的析构函数, 和 new 对应 free 只会释放内存，new 调用构造函数。

- malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是C++的运算符。它们都可用于申请动态内存和释放内存。

 

## 什么是“引用”？声明和使用“引用”要注意哪些问题？

1、引用就是某个目标变量的“别名”(alias)，对引用的操作与对变量直接操作效果完全相同。

2、声明一个引用的时候，切记要对其进行初始化。

3、引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。

4、声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用**本身不占存储单元**，系统也不给引用分配存储单元。

5、**不能建立数组的引用** ‼️。

 

## 在什么时候需要使用“常引用”？

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式： const 类型标识符 &引用名 = 目标变量名；

 

## 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?

格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }

好处：**在内存中不产生被返回值的副本**；（注意：正是因为这点原因，所以**返回一个局部变量的引用是不可取的**。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!

**注意事项：**

（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。

（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

（4）流操作符重载返回值申明为“引用”的作用：

流操作符 << 和 >>，这两个操作符常常希望被连续使用，例如：cout << “hello” <<  endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个 << 操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用 << 操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是  C++ 语言中引入引用这个概念的原因吧。

赋值操作符 =。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

 

## 引用与指针有什么区别？

**引用必须被初始化，指针不必。**

**引用初始化以后不能被改变，指针可以改变所指的对象。**

**不存在指向空值的引用，但是存在指向空值的指针。**

 

## 数组与指针的区别？

**数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。**

(1) 修改内容上的差别

```
char a[] = “hello”;
a[0] = ‘X’;

char *p = “world”;  // 注意p 指向常量字符串
p[0] = ‘X’;  // 编译器不能发现该错误，运行时错误 
```

(2) 用运算符sizeof(数组名) 可以计算出数组的容量（字节数）。sizeof(p), p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。**注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。**

 ```
 char a[] = “hello world”;
 
 char *p = a;
 
 cout << sizeof(a) << endl; // 12 字节
 
 cout << sizeof(p) << endl; // 4 字节
 ```

(3)计算数组和指针的内存容量

 ```
 void Func(char a[100]) {
     cout << sizeof(a) << endl; // 4 字节而不是100 字节
 }
 ```



## 结构与联合(共用体union)有和区别？

(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。

(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

 

## 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？

1、从定义上来说：

**重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。**

**重写：是指子类重新定义父类虚函数的方法。**

2、从实现原理上来说：

**重载：**编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些**同名函数就成了不同的函数**（至少对于编译器来说是这样的, 其实是生成了不同的符号）。

如，有两个同名函数：

```
function func(p:integer):integer; 
function func(p:string):integer;
```

那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在**编译器间就已经确定了，是静态的**。也就是说，它们的**地址在编译期就绑定了（早绑定）**，因此，**重载和多态无关**！ 

**重写：**和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。



## 分别写出BOOL, int, float, 指针类型的变量a 与“零”的比较语句。

```
BOOL : if (!a) or if(a)

int : if (a == 0)

float : 
const EXPRESSION EXP = 0.000001
if (a < EXP && a >-EXP)


pointer : 
if (a != NULL) 
or
if(a == NULL)
```



## **int (*s[10])(int)** **表示的是什么？**

int (*s[10])(int) 表示函数指针数组，每个指针指向一个 int func(int param) 的函数。‼️

 

## 栈内存与文字常量区

```
char str1[] = “abc”;
char str2[] = “abc”;

const char str3[] = “abc”;
const char str4[] = “abc”;

const char *str5 = “abc”;
const char *str6 = “abc”;

char *str7 = “abc”;
char *str8 = “abc”;

cout << (str1 == str2) << endl;//0 分别指向各自的栈内存
cout << (str3 == str4) << endl;//0 分别指向各自的栈内存
cout << (str5 == str6) << endl;//1指向文字常量区地址相同
cout << (str7 == str8) << endl;//1指向文字常量区地址相同
```

结果是：0 0 1 1

- str1, str2, str3, str4 是数组变量，它们有各自的内存空间；

- str5, str6, str7, str8是指针，它们指向相同的常量区域。

 

## 类型限定符 const volatile restrict

- const:  const 类型的对象在程序执行期间不能被修改改变。

- volatile 修饰符:  volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从**内存**中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。它通常被用于硬件地址和与其它并行运行的程序共享的数据，以防编译器会做错误的代码优化。

- restrict:  由 restrict 修饰的**指针是唯一一种访问它所指向的对象的方式**。只有 C99 增加了新的类型限定符 restrict。

 volatile 和 restrict 关键字是 C 语言中一对功能相反的关键字，这一点做嵌入式开发中应该会用到 ，详情理解可参考 volatile 和 restrict 关键字

 

## static

1、static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

2、static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

3、在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

## extern

1、extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

2、当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。



## mutable

1、仅适用于类的成员变量和 lambda 表达式中。

**2、mutabel 是专门为突破 const 限制而设定，const 修饰的成员函数无法修改成员变量（可查看），被mutabel 修饰的成员变量可被 const 成员函数修改。**

 

## thread_local

1、仅能修饰变量，不可修饰函数

2、每个独立的线程不共享这个变量，每次使用都初始化

3、生存周期为线程的生存周期

4、修饰局部变量时，生存周期同样为线程周期，不随函数结束而释放

```
示例：

#include <thread>

thread_local int g_n = 1; // g_n 属于主线程，id=8004

void f()
{
  g_n++;
  printf("id=%d, n=%d\n", std::this_thread::get_id(), g_n);
}

void foo()
{
  thread_local int i = 0;
  printf("id=%d, n=%d\n", std::this_thread::get_id(), i);
  i++;
}

void f2()
{
  foo();
  foo();
}


int main()
{
    g_n++; // 主线程中g_n = 2
    f();  // 在主线程中使用主线程(8004)中的变量g_n， 输出3

    std::thread t1(f); 
    std::thread t2(f);
    // 在一个新的线程(8008)中运行，g_n，在主线程中对g_n的修改不会影响该线程
    // 输出2
    t1.join();
    // 在一个新的线程(8012)中运行，g_n，在主线程中对g_n的修改不会影响该线程
    // 输出2
    t2.join();


    // 在主线程(8004)中执行f2，每一次foo执行完之后，i都不会被重置，
    // 因为主线程还没有结束，而thread_local 变量的生存周期是线程级别的
    // 输出0，1
    f2(); 



    std::thread t4(f2);
    std::thread t5(f2);
    // 分别在两个新的线程中执行，每次执行会初始化thread_local int i 
    t4.join();
    t5.join();

    return 0;
}

输出（id值是每次运行时变的）：
id=8004, n=3

id=8008, n=2
id=8012, n=2

id=8004, n=0
id=8004, n=1

id=8016, n=0
id=8016, n=1

id=8020, n=0
id=8020, n=1
```



## 数据抽象

数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

接口（抽象类）

接口描述了类的行为和功能，而不需要完成类的特定实现。

C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的

 

## 友元函数

1、**友元函数是一个不属于类成员的函数，但它可以访问该类的私有成员**；

2、**整个类都可以声明为另一个类的友元**

3、**友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。**

 

## 内联函数

inline 函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”

```
inline void Foo(int x, int y);  // inline 仅与函数声明放在一起, 所以不是内联的

void Foo(int x, int y)
{
 ...
}

而如下风格的函数 Foo 则成为内联函数：
void Foo(int x, int y); 

inline void Foo(int x, int y)  // inline 与函数定义体放在一起，是内联的
{
 ...
}
```

**定义:** 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

**优点:** 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 

**缺点:** 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

**结论:** 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

**另一个实用的经验准则:** 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

**有些函数即使声明为内联的也不一定会被编译器内联,** **这点很重要：** 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.

 

## array 和vector，数组三者区别和联系

**共同点**

（1.）都和数组相似，都可以使用标准数组的表示方法来访问每个元素（array 和 vector 都对下标运算符 [ ] 进行了重载）

（2.）三者的存储都是连续的，可以进行随机访问

**不同点**

（0.）数组是不安全的，array 和 vector 是比较安全的（有效的避免越界等问题）

（1.）array 对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）

（2.）array 可以将一个对象赋值给另一个 array 对象，但是数组不行

（3.）vector 属于变长的容器，即可以根据数据的插入和删除重新构造容器容量；但是 array 和数组属于定长容器

（4.）vector 和 array 提供了更好的数据访问机制，即可以使用 front() 和 back() 以及 at()（at()可以避免a[-1]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误

（5.）vector 和 array 提供了更好的遍历机制，即有正向迭代器和反向迭代器

（6.）vector 和 array 提供了 size(). 和 Empty()，而数组只能通过 sizeof()/strlen() 以及遍历计数来获取大小和是否为空

（7.）vector 和 array 提供了两个容器对象的内容交换，即 swap() 的机制，而数组对于交换只能通过遍历的方式逐个交换元素

（8.）array 提供了初始化所有成员的方法 fill()

（9.）由于 vector 的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题

（10.）vector 和 array 在声明变量后，在声明周期完成后，会自动地释放其所占用的内存。对于数组如果用 new[ ]/malloc 申请的空间，必须用对应的 delete[ ] 和 free 来释放内存